'''
This script reads the .txt file generated by Jesus Lopez's code
extracting and representing energy data
'''

import matplotlib.pyplot as plt
import math
import numpy as np


file_path = "/Users/jaimemorandominguez/Desktop/TFG/Pruebas_GLM/Salida/GLM_output_data_2.txt"

########### Reading the .txt file and writing it in a table ###########

GLM_data = np.loadtxt(file_path, delimiter=' ')
# 1st column: flash time [s]
# 2nd column: Event latitude [deg]
# 3rd column: Event longitude [deg]
# 4th column: Event ID
# 5th column: Flash latitude [deg]
# 6th column: Flash longitude [deg]
# 7th column: Radiance

########### Filling a new time-wise table with ordered time data ###########

new_length = 1
total_voids = 0;
acumulated_voids = 0
void_info = np.zeros((len(GLM_data),4))
# 1st column: .txt row
# 2nd column: void timesteps after that row
# 3rd column: timestep lower than 0.002 s (0 or 1)
# 4th column: Void timesteps before this line

# Updating new_length value to make a new table with 1st dimension being new_length

GLM_data[0,0] = round(GLM_data[0,0],3)

for i in range(1,len(GLM_data)):    # Checking for different time values and void values

    GLM_data[i,0] = round(GLM_data[i,0],3)  # Rounding makes comparison easier
    void_info[i][0] = i;                    # Filling first column
    
    if GLM_data[i,0] != GLM_data[i-1,0]:    # Avoiding same timestep values
    
        if GLM_data[i,0] == GLM_data[i-1,0] + 0.002:    # Exactly one timestep ahead
            new_length = new_length + 1
            void_info[i][3] = acumulated_voids
            
        elif GLM_data[i,0] < GLM_data[i-1,0] + 0.002:   # Less than a whole timestep (sometimes occur)
            new_length = new_length + 1
            void_info[i][2] = 1
            void_info[i][3] = acumulated_voids
            
        else:                               # There are missing timesteps in between (no radiance detected)
            void_timesteps = round((GLM_data[i,0] - GLM_data[i-1,0])/0.002) - 1
            new_length = new_length + 1 + void_timesteps
            void_info[i-1][1] = void_timesteps
            acumulated_voids = acumulated_voids + void_timesteps
            void_info[i][3] = acumulated_voids
            
# Creating the new matrix

GLM_complete_data = np.zeros((new_length,7))

for i in range(0,len(GLM_data)):
    if void_info[i,1] == 0:     # Lines of data with no timegaps just after them
        GLM_complete_data[i,:] = GLM_data[i,:]
        

########### REPRESENTATIONS ###########

# Integrated event grid and flash representation
plt.figure()
plt.scatter(GLM_data[:,2],GLM_data[:,1])
plt.scatter(GLM_data[:,5],GLM_data[:,4],marker='x')
plt.axis('equal')
plt.grid('on')
plt.title("Event grid")
plt.xlabel('Longitude [deg]')
plt.ylabel('Latitude [deg]')
plt.show()

# Radiance vs time graph representation
plt.figure()
plt.bar(GLM_data[:,0],GLM_data[:,6],width=0.005)
plt.grid('on')
plt.title("Radiance VS Time")
plt.xlabel('Time (second of the day) [s]')
plt.ylabel('Radiance [J]')
plt.show()