'''
This script reads the .txt file generated by Jesus Lopez's code
extracting and representing energy data
'''

import matplotlib.pyplot as plt
import math
import numpy as np

###################################################
##              USER INPUT DATA                  ##
###################################################

file_path = "/Users/jaimemorandominguez/Desktop/TFG/Pruebas_GLM/Salida/GLM_output_data.txt"
#min_lon = ?    # [deg]
#max_lon = ?    # [deg]

#min_lat = ?    # [deg]
#min_lat = ?    # [deg]

#start_time = 0      # [s]
#end_time = 24*3600  # [s]

###################################################
##           END OF USER INPUT DATA              ##
###################################################

########### Reading the .txt file and writing it in a table ###########

GLM_data = np.loadtxt(file_path, delimiter=' ')
# 1st column: flash time [s]
# 2nd column: Event latitude [deg]
# 3rd column: Event longitude [deg]
# 4th column: Event ID
# 5th column: Flash latitude [deg]
# 6th column: Flash longitude [deg]
# 7th column: Radiance

########### Filling a new time-wise table with ordered time data ###########

new_length = 1          # New length of the time-wise matrix
acumulated_voids = 0    # Number of non-existing timesteps up to the current line
repetition_count = 0    # Accounts for total repeted lines
void_info = np.zeros((len(GLM_data),4))     # Matrix with special info for each line:
# 1st column: .txt row number
# 2nd column: void timesteps after that row
# 3rd column: timestep lower than 0.002 s (0 or 1)
# 4th column: Accumulated void timesteps before this line

# Updating new_length value to make a new table with 1st dimension being new_length

GLM_data[0,0] = round(GLM_data[0,0],3)

for i in range(1,len(GLM_data)):    # Checking for different time values and void values

    GLM_data[i,0] = round(GLM_data[i,0],3)  # Rounding makes comparison easier
    void_info[i][0] = i;                    # Filling first column
    
    if GLM_data[i,0] != GLM_data[i-1,0]:    # Avoiding same timestep values
    
        if GLM_data[i,0] == GLM_data[i-1,0] + 0.002:    # Exactly one timestep ahead
            new_length = new_length + 1
            void_info[i][3] = acumulated_voids
            
        elif GLM_data[i,0] < GLM_data[i-1,0] + 0.002:   # Less than a whole timestep (sometimes occur)
            new_length = new_length + 1
            void_info[i][2] = 1
            void_info[i][3] = acumulated_voids
            
        else:                               # There are missing timesteps in between (no radiance detected)
            void_timesteps = round((GLM_data[i,0] - GLM_data[i-1,0])/0.002) - 1
            new_length = new_length + 1 + void_timesteps
            void_info[i-1][1] = void_timesteps
            acumulated_voids = acumulated_voids + void_timesteps
            void_info[i][3] = acumulated_voids
            
    else:                                   # Same timestep as line before
        repetition_count = repetition_count + 1
        new_length = new_length + 1
        void_info[i][3] = acumulated_voids
            
# Filling the new time-wise matrix

GLM_complete_data = np.zeros((new_length,7)) # New matrix with data with void lines for non-existing timesteps
radiance = np.zeros((len(GLM_complete_data)-repetition_count,2)) # Time-radiance integration for plotting

for i in range(0,len(GLM_data)):
    new_i = int(i + void_info[i,3])                    # Row position on the new matrix
    GLM_complete_data[new_i,:] = GLM_data[i,:]         # Filling rows with existing data
    
    if void_info[i,1] != 0:   # Valid for lines with non-existing timesteps
        counter = 1           # Adds 0.002s to every void line
        for j in range(new_i+1, new_i+1+int(void_info[i,1])):
            GLM_complete_data[j,0] = GLM_data[i,0] + counter * 0.002
            GLM_complete_data[j,range(1,7)] = 0
            counter = counter + 1

radiance[0,:] = [GLM_complete_data[0,0],GLM_complete_data[0,6]]
rad_counter = 0
for i in range(1,len(GLM_complete_data)):
    if GLM_complete_data[i,0] == GLM_complete_data[i-1,0]:
        radiance[rad_counter,:] = [GLM_complete_data[i,0], radiance[rad_counter,1]+GLM_complete_data[i,6]]
    else:
        rad_counter = rad_counter + 1
        radiance[rad_counter,:] = [GLM_complete_data[i,0],GLM_complete_data[i,6]]
        

########### REPRESENTATIONS ###########

# Integrated event grid and flash representation
plt.figure()
plt.scatter(GLM_data[:,2],GLM_data[:,1])
plt.scatter(GLM_data[:,5],GLM_data[:,4],marker='x')
plt.axis('equal')
plt.grid('on')
plt.title("Event grid")
plt.xlabel('Longitude [deg]')
plt.ylabel('Latitude [deg]')
plt.show()

# Radiance vs time graph representation
plt.figure()
plt.plot(radiance[:,0],radiance[:,1])
plt.grid('on')
plt.title("Radiance VS Time")
plt.xlabel('Time (second of the day) [s]')
plt.ylabel('Radiance [J]')
plt.show()